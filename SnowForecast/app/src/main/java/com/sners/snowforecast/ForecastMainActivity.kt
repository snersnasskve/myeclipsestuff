package com.sners.snowforecast

import android.content.Intent
import android.content.SharedPreferences
import android.location.LocationManager
import android.os.AsyncTask
import android.os.Bundle
import android.text.TextUtils
import android.util.Log
import android.view.Menu
import android.view.MenuItem
import android.view.View
import android.widget.*
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.FragmentActivity
import com.sners.snowforecast.apicall.VisualCrossingReader.timelineRequest
import com.sners.snowforecast.apicall.WeatherBitReader
import com.sners.snowforecast.databinding.ActivityForecastMainBinding
import com.sners.snowforecast.location.ForecastLocation
import com.sners.snowforecast.location.WeatherLocation
import com.sners.snowforecast.weather.WeatherData
import java.text.DecimalFormat
import java.util.*

/**
 * The primary view for the application
 */
class ForecastMainActivity : FragmentActivity() {

    /**
     * @property binding The binding class is autogenerated from the name of the layout it refers to
     */
    private lateinit var binding: ActivityForecastMainBinding

    var weatherLocations: ArrayList<WeatherLocation>? = null

    //	For the array adaptor - names only
    var favourites: ArrayList<String?>? = null
    var favouritesAdapter: ArrayAdapter<String?>? = null
    private var currentLocation: WeatherLocation? = null
    private var favouriteLocation: WeatherLocation? = null
    var forecastLocation: ForecastLocation? = null
    private var lastUsedInfo: SharedPreferences? = null
    public override fun onCreate(savedInstanceState: Bundle?) {
        // TODO Auto-generated method stub
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_forecast_main)
        binding = DataBindingUtil.setContentView(this, R.layout.activity_forecast_main)

        lastUsedInfo = getSharedPreferences("weatherinfo", MODE_PRIVATE)
        binding.pbReadWeather.visibility = View.INVISIBLE
        populateFavourites(lastUsedInfo?.getString("favourites", null))


        //favouritesAdapter =
        //		ArrayAdapter.createFromResource(ForecastMainActivity.this, favourites, );
        favouritesAdapter = ArrayAdapter(
            this@ForecastMainActivity,
            android.R.layout.simple_list_item_1, favourites!!
        )
        favouritesAdapter!!.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        binding.spFavourites.adapter = favouritesAdapter

        //	This needs to be called from Android class
        val locationMgr = getSystemService(LOCATION_SERVICE) as LocationManager
        forecastLocation = ForecastLocation(locationMgr, this@ForecastMainActivity)
        binding.spFavourites.onItemSelectedListener = favouriteItemSelected
    }

    override fun onResume() {
        super.onResume()
        if (null == currentLocation) {
            //	Only read it the first time
            readLocationFromPhone()
        }
    }

    override fun onPause() {
        saveFavourites()
        super.onPause()
    }

    override fun onStop() {
        saveFavourites()
        super.onStop()
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        // Inflate the menu; this adds items to the action bar if it is present.
        menuInflater.inflate(R.menu.forecast_main, menu)
        return super.onCreateOptionsMenu(menu)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        // Handle action bar item clicks here. The action bar will
        // automatically handle clicks on the Home/Up button, so long
        // as you specify a parent activity in AndroidManifest.xml.
        val id = item.itemId
        if (id == R.id.action_add_favourite) {
            val success = locationFromAddress
            if (success) {
                addFavourite()
            }
            return true
        } else if (id == R.id.action_remove_favourite) {
            val success = locationFromAddress
            if (success) {
                deleteFavourite()
            }
        }
        return super.onOptionsItemSelected(item)
    }

    fun saveFavourites() {
        val prefsEditor = lastUsedInfo!!.edit()
        prefsEditor.clear()
        prefsEditor.putString("favourites", favouritesToString())
        prefsEditor.apply()
        prefsEditor.commit()
    }

    /////////////////////////////////////////////
    //	Location
    /////////////////////////////////////////////
    private fun readLocationFromPhone() {
        var statusString = "Searching..."
        binding.pbReadWeather.visibility = View.VISIBLE
        binding.tvStatus.text = statusString

        //	Get location from phone
        val bestLocation = forecastLocation!!.bestLastKnownLocation()
        if (null != bestLocation) {
            currentLocation = WeatherLocation("Local", "" + bestLocation.latitude, "" + bestLocation.longitude)
            val locationString = "${locationFormat.format(currentLocation!!.latitude)}  :  ${locationFormat.format(currentLocation!!.longitude)}"
            binding.tvLocation.text = locationString
            statusString = "Current Location found"
            //	getWeatherData(currentLocation.getLatitude(), currentLocation.getLongitude());
        } else {
            statusString = "Please enable GPS"
        }
        binding.tvStatus.text = statusString
        binding.pbReadWeather.visibility = View.INVISIBLE
    }//	Get location from phone

    //	Get location from text on screen
    private val locationFromAddress: Boolean
        private get() {
            var statusString = getString(R.string.searching_status)
            binding.pbReadWeather.visibility = View.VISIBLE
            binding.tvStatus.text = statusString
            var success = false
            if (binding.etLocationPlaceName.text.toString().length > 3) {
                //	Get location from text on screen
                forecastLocation!!.locationFromPlace(binding.etLocationPlaceName.text.toString(),
                    application)
                if (forecastLocation!!.isValidLocation) {
                    val locationString = locationFormat.format(
                        forecastLocation!!.mLatitude
                    ) + "  :  " +
                            locationFormat.format(forecastLocation!!.mLongitude)
                    binding.tvLocation.text = locationString
                    statusString = getString(R.string.location_for_address_found)
                    success = true
                } else {
                    statusString = getString(R.string.try_later_no_internet)
                }
            } else {
                //	Get location from phone
                statusString = getString(R.string.enter_place_name)
            }
            binding.tvStatus.text = statusString
            binding.pbReadWeather.visibility = View.INVISIBLE
            return success
        }

    /////////////////////////////////////////////
    //	Action on Buttons
    /////////////////////////////////////////////
    fun forecastForAddress(view: View?) {
        if (binding.etLocationPlaceName.text.toString().length > 3) {
            locationFromAddress
            Toast.makeText(
                applicationContext, getString(R.string.show_forecast_this_address),
                Toast.LENGTH_SHORT
            ).show()
            Log.i(TAG, "forecastForAddress - Leaving main thread")
            getWeatherData(forecastLocation!!.mLatitude, forecastLocation!!.mLongitude)
        }
    }

    fun forecastForLocation(view: View?) {
        binding.etLocationPlaceName.setText("")
        Toast.makeText(
            applicationContext, getString(R.string.show_forecast_this_location),
            Toast.LENGTH_SHORT
        ).show()
        Log.i(TAG, "forecastForLocation - Leaving main thread")
        getWeatherData(currentLocation!!.latitude!!, currentLocation!!.longitude!!)
    }

    fun forecastForFavourite(view: View?) {
        if (favouriteLocation != null) {
            Toast.makeText(
                applicationContext, "Show forecast for this preset",
                Toast.LENGTH_SHORT
            ).show()
            Log.i(TAG, "forecastForFavourite - Leaving main thread")
            getWeatherData(favouriteLocation!!.latitude!!, favouriteLocation!!.longitude!!)
        }
    }

    fun refreshScreen(view: View?) {
        //readLocationFromPhone();
        Toast.makeText(
            applicationContext, "Re-read loaction and show forecast for this location",
            Toast.LENGTH_SHORT
        ).show()
        if (null != currentLocation) {
            Log.i(TAG, "refreshScreen - Leaving main thread")
            getWeatherData(currentLocation!!.latitude!!, currentLocation!!.longitude!!)
        } else {
            binding.tvStatus.text = getString(R.string.location_not_found_warning)
            Toast.makeText(
                applicationContext, getString(R.string.location_not_found_warning),
                Toast.LENGTH_SHORT
            ).show()
        }
    }

    /////////////////////////////////////////////
    //	Favourites
    /////////////////////////////////////////////
    private fun populateFavourites(favouritesString: String?) {
        favourites = ArrayList()
        weatherLocations = ArrayList()
        favourites!!.add("")
        weatherLocations!!.add(WeatherLocation())
        if (null != favouritesString) {
            //asList is a disaster, bar is being used as a regex
            val tempLocList = Arrays.asList(*TextUtils.split(favouritesString, "\\|"))
            for (locStringInst in tempLocList) {
                val locInst = WeatherLocation(locStringInst)
                weatherLocations!!.add(locInst)
                favourites!!.add(locInst.name)
            }
        }
    }

    var favouriteItemSelected: AdapterView.OnItemSelectedListener = object : AdapterView.OnItemSelectedListener {
        override fun onItemSelected(
            parent: AdapterView<*>?, view: View,
            position: Int, id: Long
        ) {
            binding.etLocationPlaceName.setText(weatherLocations!![position].name)
            if (weatherLocations!![position].name!!.length > 3) {
                binding.tvLocation.text =
                    "" + weatherLocations!![position].latitude + "" + "  :  " + weatherLocations!![position].longitude
                favouriteLocation = weatherLocations!![position]
            }
        }

        override fun onNothingSelected(parent: AdapterView<*>?) {
            // TODO Auto-generated method stub
        }
    }

    private fun favouritesToString(): String? {
        var favString: String? = null
        if (weatherLocations!!.size != 0) {
            val weatherStringArray = ArrayList<String?>()
            for (locInst in weatherLocations!!) {
                if (locInst.name != "") {
                    weatherStringArray.add(locInst.toString())
                }
            }
            favString = TextUtils.join("|", weatherStringArray)
        }
        return favString
    }

    private fun addFavourite() {
        var statusString = "Please enter valid place name"
        val placeName = binding.etLocationPlaceName.text.toString()
        if (placeName.length > 3) {
            statusString = if (favourites!!.contains(placeName)) {
                "$placeName is already in your favourites"
            } else {
                val newLocation = WeatherLocation(placeName, binding.tvLocation.text.toString())
                if ("" !== newLocation.name) {
                    weatherLocations!!.add(newLocation)
                    favouritesAdapter!!.add(placeName)
                    binding.spFavourites.setSelection(favourites!!.size - 1)
                    "$placeName has been added"
                } else {
                    "Get location before adding to favourites"
                }
            }
        }
        binding.tvStatus.text = statusString
    }

    private fun deleteFavourite() {
        var statusString = getString(R.string.select_place_to_delete)
        val placeName = binding.etLocationPlaceName.text.toString()
        if (placeName.length > 3) {
            var placeToDelete: WeatherLocation? = null
            for (locInst in weatherLocations!!) {
                if (locInst.name == placeName) {
                    placeToDelete = locInst
                }
            }
            if (null != placeToDelete) {
                weatherLocations!!.remove(placeToDelete)
                favouritesAdapter!!.remove(placeName)
                statusString = "$placeName has been deleted"
               binding.spFavourites.setSelection(0)
            }
        }
        binding.tvStatus.text = statusString
    }

    /////////////////////////////////////////////
    //	Read forecast
    /////////////////////////////////////////////
    private fun getWeatherData(mLatitude: Double, mLongitude: Double) {
        binding.pbReadWeather.visibility = View.VISIBLE
        ReadWeatherAsyncTask().execute(mLatitude, mLongitude)
    }

    // Use AsyncTask if you need to perform background tasks, but also need
    // to change components on the GUI. Put the background operations in
    // doInBackground. Put the GUI manipulation code in onPostExecute
    private inner class ReadWeatherAsyncTask : AsyncTask<Double?, Double?, String>() {
        protected override fun doInBackground(vararg params: Double?): String? {
            var errorMessage = ""
            try {
                //  Please make a string resource file called secrets.
                //  Your api key should do in there
                val apiKey = resources.getString(R.string.visual_crossing_api_key)
                timelineRequest(params[0]!!, params[1]!!, apiKey)
            } catch (e: Exception) {
                e.printStackTrace()
                errorMessage = "Unable to read weather - please try later when you have internet"
            }
            try {
                //  Please make a string resource file called secrets.
                //  Your api key should do in there
                val apiKey = resources.getString(R.string.weather_bit_api_key)
                WeatherBitReader.timelineRequest(params[0]!!, params[1]!!, apiKey)
            } catch (e: Exception) {
                e.printStackTrace()
                errorMessage = "Unable to read weather - please try later when you have internet"
            }
            if ("" === errorMessage) {
                weatherData = WeatherData(rawMinutely, rawHourly)
            }
            return errorMessage
        }

        override fun onPostExecute(result: String) {
            showCurrentWeather(result)
            binding.pbReadWeather.visibility = View.INVISIBLE
        }
    }

    private fun showCurrentWeather(weatherJson: String?) {
        if (null != weatherJson && "" === weatherJson) {
            Log.i(TAG, "showCurrentWeather - rejoined main thread")
            //Intent currentIntent = new Intent(ForecastMainActivity.this, WeatherDashboard.class);
            val currentIntent = Intent()
            currentIntent.setClassName(this@ForecastMainActivity, "com.sners.snowforecast.view.WeatherDashboard")
            startActivity(currentIntent)
        } else {
            binding.tvStatus.text = getString(R.string.failed_no_internet_warning)
        }
    }

    companion object {
        var TAG = "ForecastMainActivity"

        //	Location
        private val locationFormat = DecimalFormat("0.00000")
        @JvmField
        var weatherData //	Data needs to be omnipresent
                : WeatherData? = null
        var rawMinutely = ""
        var rawHourly = ""
    }
}